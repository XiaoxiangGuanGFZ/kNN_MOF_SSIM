---
title: "AnalogyCounts"
author: "guan"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Method of fragments (MPF) is a common algorithm for rainfall temporal disaggregation.
when applied in multi-site scale rainfall disaggregation, the analog day filter criterion wet-dry status is applied to filter the candidates with the exactly same wet-dry status with the target day (the day to be disaggregated). In our experience, the more criteria we put in candidate days filtering, the smaller the sample size of the candidate pools. For the extreme case, we can not find any candidates when the disaggregation domain gets very large or too many rainfall sites are considered in disaggregation in the meantime. 

Therefore, we first want to analyze the sensitivity of counts of candidates (pool size) to the criteria we impose. The criteria include wet-dry status, 3-day wet-dry status (1 day before and after the target day), circulation patterns, and seasonality. 

```{r libs, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)
```


```{r data_pre}
ws <- "D:/kNN_MOF_SSIM/"
n = 134
df_obs_dly <- read.table(
  paste0(ws, "data/rr_obs_daily.csv"),
  header = F, sep = ","
)
years <- seq(df_obs_dly$V1[1], tail(df_obs_dly$V1, 1), 1)
df_cp <- read.table(
  paste0(ws, "data/cp_series.csv"),
  header = F, sep = ","
) %>% `colnames<-`(
  c("y", "m", "d", "cp")
) %>% filter(
  y >= years[1],
  y <= tail(years, 1)
)

```

## Wet-dry status filtering


```{r func_WD}
WD1 <- function(x, y, n)
{
  wd = 1
  for (i in 1:n) {
    if ((x[i] > 0 && y[i] == 0) || (x[i] == 0 && y[i] > 0))
    {
      wd = 0
      break
    }
  }
  return(wd)
}
```


```{r WD1, cache=TRUE}
CanCounts <- NULL
for (i in 1:length(df_obs_dly$V1)) {
  ts_target <- as.numeric(df_obs_dly[i, 4:(3 + n)])
  if (sum(ts_target) == 0) {
    CanCounts[i] = NA
  } else {
    CanCounts[i] = 0
    y = df_obs_dly$V1[i]
    df_cans = df_obs_dly[df_obs_dly$V1 != y, ]
    for (j in 1:dim(df_cans)[1] ) {
      wd_status = WD1(ts_target, df_cans[j, 4:(3 + n)], n)
      CanCounts[i] = CanCounts[i] + wd_status
    }
  }
}

df_counts <- data.frame(
  df_obs_dly[, 1:3],
  CanCounts
) %>% `colnames<-`(
  c("y", "m", "d", "count")
)
head(df_counts)

```

```{r WD1_plot}
(nday <- length(df_counts$count))
(nNAs <- sum(is.na(df_counts$count)))
(nZero <- sum(df_counts$count == 0, na.rm = TRUE))

ggplot(data = df_counts, aes(x = count)) +
  geom_histogram(binwidth=10, colour="black", fill="white")

```

So, the result is very obvious. 
Almost **`r round(nZero / nday * 100, 1)`%** of the days have no match candidates if the wet-dry status filtering is strictly imposed. Therefore, the original MOF method is no more suitable (or applicable) for temporal disaggregation when too many rain sites are taken into consideration at the same time. 

It is urgent or very necessary to find alternative candidates searching strategy. 




